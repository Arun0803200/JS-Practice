===============================================================================================================
1ï¸âƒ£ Core MongoDB Topics (Must-Know)
===============================================================================================================
1. What is MongoDB & when to use it vs MySQL
* MongoDB is a NoSQL.
* MongoDB is Document orientated Database That store data in JSON-Like documents (BSON)
        > Data is stored as documents
        > Documents are grouped into collections

Example (MongoDB document)
{
  "_id": "123",
  "name": "Arun",
  "email": "arun@gmail.com",
  "orders": [
    { "orderId": 1, "amount": 500 },
    { "orderId": 2, "amount": 1200 }
  ]
}

When to Use MongoDB
-------------------
* Data structure is dynamic or frequently changing (You can add or remove data on any time)
* You need fast development and flexibility
* Application handles large volumes of data
* Data is hierarchical or nested
---------------------------------------------------------------------------------------------------------------
Document, Collection, Database
 -----------------------------
 * Document is one single record on Collection (Like table row).
 * Collection is a collections of multiple records (Like Table).
 * Database is Collection of multiple Collections.

---------------------------------------------------------------------------------------------------------------
BSON vs JSON
------------
JSON is for communication from bach end to front end, BSON is for store on mongo db its like "Machine language" 

    JSON
    * JSON (Java Script Object Notation) is humab readable format.

    BSON
    * BSON (Binary JSON) is not human readable
    * BSON is read and write is very fast
    * It has additional data Types
---------------------------------------------------------------------------------------------------------------

Schema-less vs schema validation
--------------------------------
    Schema less:
    * Schema less means in same document have different key and values
        Its makes easy to change requirements.
        Fast development.
        Don't alter table.

    schema validation:
    * MongoDB allow schema validation using JSON Schema
        Still its get flexibility.
        But with rules.

| Feature     | Schema-less  | Schema validation |
| ----------- | ------------ | ----------------- |
| Structure   | Not enforced | Rules enforced    |
| Flexibility | Very high    | Controlled        |
| Data safety | Low          | High              |
| Best for    | Prototypes   | Production        |

---------------------------------------------------------------------------------------------------------------

Embedded documents vs references
--------------------------------
    Embedded documents: 
    * Embedded documents means can store related documents on same documents.

        When use embedded documents:
            * One Read gives everything
            * No Joins needed
            * One to few relationship
            * Data doesn't grow infinitely
        
        When Embedded is bad:
            * Embedded of arrays grow too large
            * Data Update frequently
            * Data shared by many documents

    References:
    * References means stored data separatlely and link them using an ID.

        When References is good
            * One-To-Many (Large Data)
            * Many-To-Many Relation ship
            * Data reuse across collections
            * Data grow with out limit

        When References is bad
            * Too many Joins
            * Its make slow reads


---------------------------------------------------------------------------------------------------------------

===============================================================================================================
ğŸ“Œ CRUD Operations
===============================================================================================================
insertOne, insertMany
---------------------
    insertOne:
        insertOne() is used to insert one document into a collection
    
    insertMany:
        insertMany is used to insert multiple documents at once

---------------------------------------------------------------------------------------------------------------
find, findOne
---------------------

    findOne:
        findOne() returns only one matching document.
    
    find:
        find() returns all matching documents.

---------------------------------------------------------------------------------------------------------------

Filters ($eq, $ne, $in, $nin)
-----------------------------
    $eq -> Match exact value
        eg. db.users.find({ age: { $eq: 25 } })

    $ne -> Match values NOT equal to something
        eg. db.users.find({ city: { $ne: "Chennai" } })

    $in -> Value should be in given arrays
        eg. db.users.find({ city: { $in: ["Chennai", "Bangalore"] } })

    $nin -> Value should not be in given arrays
        eg. db.users.find({ city: { $nin: ["Chennai", "Bangalore"] } })
---------------------------------------------------------------------------------------------------------------

Projection
----------
    * Projection is used to choose which field need to retuen on fields
    
| Value | Meaning       |
| ----- | ------------- |
| `1`   | include field |
| `0`   | exclude field |


    * Projection in MongoDB is used to specify which fields should be included or excluded in query results,
     helping reduce data size and improve performance.

---------------------------------------------------------------------------------------------------------------

Sorting, Pagination (skip, limit)
---------------------------------

    * Sorting means ordering the results
        1 â†’ ascending (A â†’ Z, small â†’ big)
       -1 â†’ descending (Z â†’ A, big â†’ small)
            eg. db.users.find().sort({ age: 1 })

    * Pagination (limit & skip)
        Show data page by page insted of everything
            eg. db.users.find().limit(5)
                db.users.find().skip(5)
                db.users.find().skip(5).limit(5)
                db.users
                    .find()
                    .sort({ createdAt: -1 })
                    .skip(10)
                    .limit(5)

---------------------------------------------------------------------------------------------------------------

Update operators:
-----------------
$set, $unset

    * $set => is used to add a new field or Update an existing field in a document
        eg. db.user.updateOne({_id: 1}, {$set: {age: 25, name: "Arun"}});

    * $unset => is used to delete a field completly from a document
        eg. db.user.updateOne({_id: 1}, {$unset: {age: ""}});

$inc, $push, $pull
------------------

    * $inc => is used to increase or decrease a numeric value (Atomic Update)
        + eg. db.user.updateOne({_id: 1}, {$inc: {totalAmount: 100}}); => totalAmount + 100
        - eg. db.user.updateOne({_id: 2}, {$inc: {totalAmount: -100}}); => totalAmount - 100 
    
    * $push => is used to add items into an array
        eg. db.user.updateOne({_id: 1}, {$push: {skills: "MongoDB"}});
    
    * $pull => is used to remove items into an array
        eg. db.user.updateOne({_id: 1}, {$pull: {skills: "PHP"}});
---------------------------------------------------------------------------------------------------------------

deleteOne, deleteMany
---------------------
    * deleteOne => Used to delete only the first document that matches the condition.
        eg. db.user.deleteOne({name: "Ajan"});
        result: {
                    acknowledged: true,
                    deletedCount: 1
                }
    
    * deleteMany => Used to delete all documents that match the condition.
        eg. db.user.deleteMany({ email: "123@gmail.com" });

===============================================================================================================
2ï¸âƒ£ Indexing & Performance (Very Important ğŸ”¥)
===============================================================================================================

What is an index?
-----------------
    * The index is a Data Structure That helps the database to find the data faster
    * If there is no index on a table, searching data with condition will require scanning all row in the table

Types of indexes:
-----------------
    * Single field:
        => Index on only one field
            .eg db.users.createIndex({email: 1});
    
    * Compound:
        => Index on multiple fields (order matters)
            .eg db.users.createIndex({email: 1, createAt: -1})

    * Text Index:
        => Used for text searching
            .eg db.posts.createIndex({ title: "text", description: "text" });
                db.posts.find({ $text: { $search: "mongodb" } });

    * Unique index:
        => Ensure no duplicate values
            .eg db.users.createIndex({email: 1}, {unique: true});

---------------------------------------------------------------------------------------------------------------

When indexes improve performance
--------------------------------
    * Indexes improve performance when the Mongo DB can Avoid the scanning entire collections AND directly
      located the required documents
    * Indexes help for sort(), $gt, $lt, $gte and $lte
    * Index only fields used in:
        find()
        sort()
        join / lookup
        frequent filters

Downsides of indexes
    âŒ Slow write Operations
        Every INSERT, UPDATE, DELETE must also update the index (insert â†’ write data + update index)
        ğŸ‘‰ More indexes = slower writes
    
    âŒ Extra memory usage
        Indexes are store in RAM + Disk.
         ğŸ‘‰ Large indexes = More Memory

    âŒ Extra storage cost
        Each index takes disk space

    âŒ Indexes on low-selectivity fields donâ€™t help much.
        Examples:
            status (active/inactive)
            isDeleted (true/false)
---------------------------------------------------------------------------------------------------------------
explain() and query performance
-------------------------------
    * explain() is used to show how the mongo db execute the query.
         ğŸ‘‰ Is an Index used or not
         ğŸ‘‰ How many Documents where scanned
         ğŸ‘‰ How fast the query was
            eg. db.users.find({email: "abc@gmail.com"}).explain();

:- Be ready to explain how you used indexes in your live project.
===============================================================================================================
3ï¸âƒ£ Aggregation Framework (Most Asked)
===============================================================================================================

What is aggregation?
--------------------
    * Aggregation on mongo db is a framework.
    * It is Used to process, Transform & Analyze Data
    * Aggregation is used to when find() method is not enough, eg. Need Reports then goes to aggregation.

Aggregation Pipe-Line
---------------------
    * MongoDB Aggregation is Works as a Pipe-Line
        Input â†’ Stage 1 â†’ Stage 2 â†’ Stage 3 â†’ Output
    * Each stage:
        -> Take input from previous stage.
        -> Process data.
        -> Processes Output to the next stage.

$match:
-------
    * It Is used to filter documents (like where in MySQL)
        .eg {$match:  {status: 'active'}}

$group:
-------
    * It is used to group the documents and performs the calculations
        .eg {
            $group: {
                _id: "$userId",
                totalAmt: {$sum: "$amount"}
            }
        }

$project:
---------
    * It is used to Selects or reshapes the fields.
        .eg {
              $project: {
                userId: 1,
                totalAmount: 1,
                _id: 0
              }
            }

$sort:
------
    * It is used to sort the result
        .eg { $sort: { totalAmount: -1 } }

$lookup (very common):
----------------------
    * Perform join between collections
        .eg {
              $lookup: {
                from: "users",
                localField: "userId",
                foreignField: "_id",
                as: "user"
              }
            }

$unwind:
--------
    * It is used to get multiple document into single object from array of lookup
        .eg db.orders.aggregate([
                                  { $unwind: "$items" }
                                ]);

$limit, $skip:
--------------
    * Boths are used to controll how many documents are returned.

---------------------------------------------------------------------------------------------------------------
Example questions:
â€œHow do you calculate total sales per user?â€


â€œHow do you join two collections?â€
===============================================================================================================
4ï¸âƒ£ Data Modeling (Interview Favorite)
===============================================================================================================

Embedding vs Referencing:
-------------------------
    * Embedded:
        => Embedded means storing related data on same documents.
        => Child data is not dynamically grow then goes to store the data as embedded.
        PROs:
            * Fast reading (Single Query)
            * No Joins required
            * Atomic Update
        CONs:
            * Document size can grow
            * Duplication risk
            * 16 MB documnet limit
    
    * Referencing:
        => Storing related data on separate collection.
        When to use Referencing ?
            * one-to-many (large)
            * many-to-many
            * Data grows unbounded
            * data access independently
        PROs:
            * Smaller document
            * No size limit issues
            * Avoid or Less Duplication
        CONs:
            * Require $lookup (join)
            * More queries
            * Slightly slower reads

One-to-One (1:1):
-----------------
    * One document related to only one document.
        eg. User -> Profile, Student -> Id card.

One-to-Many (1:n):
------------------
    * One document related to many Documents.
        eg. User -> Order, Category -> Product.



Many-to-Many (M:N):
-------------------
    * Many documents related to many other documents
        eg. Users <-> Roles, Students <-> Courses,Product <-> Related-Product 


How you designed collections in your project ?
----------------------------------------------
    * When design collection i focused about 
        => read Vs write frequency
        => Document size growth
        => Indexing and performance
        => Relationship type (1:1), (1:n), (M:n)
        => Avoided over-normalization

Handling large arrays:
======================
    * Large arrays are dangerous on MongoDB because:
        => Document size increases
        => Updates becomes heavy
        => 16MB Document size limit

Avoiding document growth issues:
--------------------------------
    * MongoDB document should not grow uncontrollably.
    * Problem with growing documents:
        => Document relocation on storage
        => Performance degradation
        => 16MB Hard limit
        => Slower Updates


ğŸ‘‰ Compare this with MySQL normalization â€” huge plus for you.

5ï¸âƒ£ MongoDB with Node.js (Your Real Strength ğŸ’ª)
You should be very confident here.


MongoDB with:


Mongoose vs Native Driver




Mongoose:


Schema & Models


Validation


Middleware (pre, post hooks)


Populate


Lean queries




Connection handling


Error handling


Transactions (sessions)



6ï¸âƒ£ Transactions & Consistency


ACID in MongoDB


When transactions are needed


Multi-document transactions


Differences vs MySQL transactions



7ï¸âƒ£ Replication & Scalability (Midâ€“Senior Level)
Even basic understanding is enough.


Replica Set


Primary & Secondary


Read preference


Write concern


Sharding (basic idea)


Horizontal vs Vertical scaling



8ï¸âƒ£ Security & Production Topics


Authentication & Authorization


Role-based access


Environment variables


Preventing injection attacks


Backup & Restore (mongodump, mongorestore)


Monitoring basics



9ï¸âƒ£ Comparison Questions (MongoDB vs MySQL) â­
This is where your 4 years MySQL experience shines.
Be ready for:


When to choose MongoDB over MySQL


Schema flexibility vs strict schema


Joins vs $lookup


Transactions


Performance differences


Scaling strategies


Interviewers love real-world tradeoffs, not textbook answers.

ğŸ”Ÿ Project-Based Questions (Most Important)
They WILL ask:


Project architecture


Why MongoDB was chosen


Collections design


Indexes used


Performance issues faced


Production bugs & how you fixed them


Data migration


Backup strategy


ğŸ‘‰ Prepare a 2â€“3 minute story of your MongoDB project.

How to Position Your Experience (Very Important ğŸ¯)
Say this confidently:

â€œI have 4 years of strong relational database experience with MySQL and around 6 months of hands-on MongoDB experience in a live production project, where I handled data modeling, aggregation, indexing, and Node.js integration.â€

This sounds senior, not junior.

Final Preparation Strategy (2 Weeks Plan)
Week 1


MongoDB basics + CRUD


Indexing


Aggregation


Practice queries daily


Week 2


Data modeling


Node.js + Mongoose


Transactions


MongoDB vs MySQL


Mock interview questions



If you want, next I can:


ğŸ”¥ Give MongoDB interview questions & answers


ğŸ§  Create real project-based MongoDB Q&A


ğŸ“ Help you frame perfect interview answers using your live project


Just tell me ğŸ‘